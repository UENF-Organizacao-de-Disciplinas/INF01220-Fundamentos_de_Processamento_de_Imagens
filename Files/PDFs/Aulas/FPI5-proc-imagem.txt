ExtraÃ§Ã£o de CaracterÃ­sticas




                      Rivera
â€¢Sistemas de anÃ¡lise de Imagens
  â€¢Reconhecimento de elementos e objetos
    â€¢ParÃ¢metros quantificÃ¡veis
       â€¢ Cor, posiÃ§Ã£o, orientaÃ§Ã£o, dimensÃµes, textura, etc.
   Imagem
                      BD de
SegmentaÃ§Ã£o:          PadrÃµes
Separa objeto
  ou padrÃ£o

                                                  Reconhece
CaracterizaÃ§Ã£o                   Classificador
                                                   o PadrÃ£o


    Etapas de um sistema de reconhecimento de padrÃµes.
             SegmentaÃ§Ã£o
DivisÃ£o da imagem em regiÃµes que possuem o mesmo
      conteÃºdo no contexto de uma aplicaÃ§Ã£o.
                      A segmentaÃ§Ã£o baseada em:
                     â€¢ Descontinuidades
                         â€¢ MudanÃ§as bruscas de tons
                     â€¢ Similaridades
                         â€¢ aspectos comuns com limiar
                     â€¢ Limites ou bordas
                     â€¢ Ãreas ou regiÃµes
 SegmentaÃ§Ã£o Baseada em RegiÃµes
PartiÃ§Ã£o da imagem baseada no conteÃºdos de grupos de pixels.
Premissas:
(1) Homogeneidade da regiÃ£o (com tolerÃ¢ncia)
(2) RegiÃµes delimitadas por fronteiras contÃ­nuas
(3) Pontos que correspondem a uma Ãºnica regiÃ£o
(4) O conjunto de todas as regiÃµes deve formar a imagem
TÃ©cnicas:
â€¢ SegmentaÃ§Ã£o por crescimento de regiÃµes
â€¢ SegmentaÃ§Ã£o por divisÃ£o e fusÃ£o de regiÃµes
â€¢ SegmentaÃ§Ã£o por clusterizaÃ§Ã£o
â€¢ SegmentaÃ§Ã£o por janelas (windows)
        SegmentaÃ§Ã£o por crescimento de regiÃµes
â€¢ Iniciar a partir de um pixel ou um conjunto de pixels
  (denominado de â€œsementeâ€).
â€¢ Para cada semente avalia-se o predicado dos pixels vizinhos
  â€¢ Ex. cor RGB com menos de 5% da variaÃ§Ã£o de 5 pixels
    vizinhos
â€¢ A agregaÃ§Ã£o das regiÃµes Ã© feita quando o critÃ©rio de similaridade
  ou de decisÃ£o do predicado for verdadeiro.
â€¢ CritÃ©rio de parada bem definido
     SegmentaÃ§Ã£o por divisÃ£o e fusÃ£o de regiÃµes
â€¢ Subdivide uma imagem em quadtree
   â€¢ Verificar se os pixels atendem a algum critÃ©rio de
     homogeneidade.
â€¢ Os blocos que atenderem ao critÃ©rio nÃ£o serÃ£o mais divididos.
â€¢ O bloco que nÃ£o atender serÃ¡ subdividido em blocos menores.
â€¢ Realiza a junÃ§Ã£o dos blocos vizinhos homogÃªneos.
SegmentaÃ§Ã£o por â€œclusterizaÃ§Ã£oâ€
                  Algoritmo K-Means
â€¢ Algoritmo de classificaÃ§Ã£o nÃ£o-supersionada.
â€¢ O critÃ©rio a ser minimizado Ã© definido em funÃ§Ã£o da
  distÃ¢ncia dos elementos em relaÃ§Ã£o aos centros dos
  agrupamentos.
â€¢ Usualmente, a mÃ©trica Ã© a distÃ¢ncia Euclidiana.
â€¢ Quanto menor for este valor, mais homogÃªneos serÃ£o os
  objetos dentro de cada grupo e melhor serÃ¡ a partiÃ§Ã£o.
Algoritmo K-Means

        Kmeans (X, k)


   Select the k initial centers
    {ci = Random(X)}i=1,â€¦,k


   Copy ci â†’ cci, âˆ€ğ‘– = 1, â€¦ , ğ‘˜

 Clusters gerator with center cci
       âˆ€ğ‘¥ âˆˆ ğ‘‹ ğ‘–ğ‘› ğ¶1, â€¦ , ğ¶ğ‘˜

   Re-compute clusters center
       ğ‘ğ‘– = ğ‘€ğ‘’ğ‘ğ‘› ğ¶ğ‘– i=1,..,k


   Varies = Compare (ci, cci)


   Y         Varies?

                   N
       Solution {C1,â€¦,Ck
                          Outras tÃ©cnicas
â€¢ Filtragem no domÃ­nio espacial
    ï· SegmentaÃ§Ã£o na prÃ³pria imagem
        â€¢ Sem transformaÃ§Ãµes
        â€¢ Uso de medidas calculadas na imagem
â€¢ Filtragem no domÃ­nio da freqÃ¼Ãªncia
    ï· No espaÃ§o de transformada de Fourier
â€¢ TransformaÃ§Ã£o para um espaÃ§o de medida especÃ­fico
   ï· No espaÃ§o Euclidiano
        â€¢ TransformaÃ§Ã£o linear para outro espaÃ§o
             â€“ Ex. transformada de Hough, wavelets
â€¢ Baseadas em Morfologia MatemÃ¡tica
   ï· Transformada watershed (divisor de Ã¡guas)
â€¢ Contornos ativos â€“ ou modelos deformÃ¡veis
    ï· Snakes â€“ extraÃ§Ã£o de bordas de objetos da cena
        â€¢ Contorno ajustado a curvas (splines)
        â€¢ Inicialmente uma configuraciÃ³n inicial evolui atÃ© se ajustar ao objeto de
          interese
â€¢ 5/10
â€¢ Luis
â€¢ Yuri
â€¢ Maria
           Propriedades do Pixel


Retangular ou quadrada. TrÃªs aspectos a considerar:
â€¢VizinhanÃ§a em Pixel (VizinhanÃ§a-4 e VizinhanÃ§a-8)
â€¢Medidas de DistÃ¢ncia
â€¢Conectividade
   * Propriedade de um pixel estÃ¡ conectado a outro)
VizinhanÃ§a em Pixel (VizinhanÃ§a-4 e VizinhanÃ§a-8)

   Quais sÃ£o os vizinhos de um determinado pixel?
   â€¢ Importante para segmentaÃ§Ã£o e continuidade do objeto


                                  vizinhanÃ§a-4 de p - N4(p)



                                  vizinhanÃ§a-D de p â€“ ND(p)




                                  vizinhanÃ§a-8 de p â€“ N8(p)
                          Medidas de DistÃ¢ncia
 DistÃ¢ncia city-block, Manhatan ou quarteirÃ£o para e
 distÃ¢ncia Euclidiana para :
                                      1
                       ïƒ©n           rïƒ¹r
      D( X i , X j ) = ïƒªïƒ¥ xil âˆ’ x jl ïƒº         Xi, Xj vetor de elementos
                       ïƒªïƒ« l =1       ïƒºïƒ»




DistÃ¢ncia Euclidiana      DistÃ¢ncia Manhattan D(p,q) = MÃ¡x |xixâ€“xjx|,|xiyâ€“xjy|} â‰¤ 2
â‰¤ âˆš8 do pixel central     D1 = |xixâ€“xjx|+|xiyâ€“xjy|
                       Conectividade

Dois pixels estÃ£o conectados se:
â€¢ sÃ£o adjacentes (N4(p) ou N8(p)); e,
â€¢ atributos (nÃ­veis de cinza, texturas ou cores) similares.


NÃ­veis de conectividade:
Â§ Conectividade de 4: q estÃ¡ em N4(p) e atributos iguais.
Â§   Conectividade de 8: q estÃ¡ em N8(p) e atributos iguais.
                Tipos de caracterÃ­sticas
  Qual
                               CaracterÃ­sticas
escolher?

                  De forma                       De aspecto


  De contorno                 De regiÃµes         Rugosidade
                                                 Cor
                                                 Textura


   Dimensionais                Inerciais              TopolÃ³gicas


 Ãrea                    Centro geomÃ©trico       NÃºmero de furos
 PerÃ­metro               Momento                 NÃºmero de Euler
 Excentricidade          OrientaÃ§Ã£o              Componentes conectados
 Compacidade             RetÃ¢ngulo envolvente    NÃºmero de vÃ©rtices
 Raio mÃ¡ximo             Elipse ajustada
 Raio mÃ­nimo
      AnÃ¡lise de Componentes Principais (PCA)

â€¢Componentes
   â€¢ principal representa melhor a distribuiÃ§Ã£o dos dado
   â€¢ secundÃ¡ria Ã© perpendicular Ã  componente principal.

â€¢Passos:
   â€¢ Obter as n amostras
   â€¢ Calcular a mÃ©dia
   â€¢ Calcular a matriz de covariÃ¢ncia
   â€¢ Calcular os autovalores e autovetores da matriz de covariÃ¢ncia
   â€¢ Componente principal e secundaria: autovetores de maior e menor autovalor,
     respectivamente.
                Matriz de covariÃ¢ncia

A matriz de covariÃ¢ncia para M amostras de vetores pi, com
vetor mÃ©dio m pode ser calculada de acordo com:



                       ïƒ¥ (xi âˆ’ mx )(yi âˆ’ m y )
                       M
                   1
              Cx =
                   M   i =1



    O vetor mÃ©dio pode ser calculado:

                              M
                              ïƒ¥ pi
                     1
                  m=
                     M        i =1
                                                          c_triple_real32 *obbtree_calcula_autovetores(c_triple_real32 *cov, c_real32
                                                          *lambda)
c_real32 *calcula_autovalores(c_triple_real32 *cov)       {
{                                                                c_uint16 x, y; c_triple_real32 *xy; c_real32 m1, m2;
      c_uint16 x, y; c_real32 *lambda; c_real32 m;              x =0; y =1;
      lambda = aloca_array_real32((c_uint16)2);                 xy = aloca_array_triple_real32((c_uint16)3);
      x =0; y =1;                                                if((lambda[0] == 0.0f) && (lambda[1] == 0.0f)) // se for circulo
      m = sqrt(pow((cov[x][x] - cov[y][y]), 2)                  {
               + 4.0f*pow(cov[x][y], 2));                              ca_scala_triple_real32(v_un_x, 1.0f, xy[0]); // vetor unitario (1,0)
      lambda[0] = ((cov[x][x] + cov[y][y] + m) / 2.0f);                ca_scala_triple_real32(v_un_y, 1.0f, xy[1]); // vetor unitario (0,1)
      lambda[1] = ((cov[x][x] + cov[y][y] - m) / 2.0f);         } else {
      return lambda;                                                   xy[0][0] = (c_real32)(-1.0f * cov[x][y]);
}                                                                      xy[0][1] = cov[x][x] - lambda[0];
                                                                       xy[0][2] = 0.0f;
                                                                        m1 = ca_modulo_triple_real32(xy[0]);
                                                                       xy[1][0] = (c_real32)(-1.0f * cov[x][y]);
                                                                       xy[1][1] = cov[x][x] - lambda[1];
                                                                       xy[1][2] = 0.0f;
                                                                        m2 = ca_modulo_triple_real32(xy[1]);
                                                                        if(m1 > m2) {
                                                                            m2 = (c_real32)1.0f / m1;
                                                                            ca_scala_triple_real32(xy[0], m2, xy[0]);
 Vetor caixa_retangular(float [][] cov)                                    xy[1][0] = (c_real32)(-1.0f * xy[0][1]);
 {                                                                          xy[1][1] = xy[0][0];
       calcula_matriz_covariancia_area(vetor pts)                      }     else   {
       lambda = calcula_autovalores(cov);                                  m1 = (c_real32)1.0f / m2;
       ordena_autovetores_para_eixos(lambda);                              ca_scala_triple_real32(xy[1], m1, xy[1]);
       xy = calcula_autovetores(cov, lambda);                              xy[0][0] = (c_real32)(-1.0f * xy[1][1]);
 }                                                                         xy[0][1] = xy[1][0];
                                                                       }
                                                                }
                                                                return xy;
                                                          }
    AutoespaÃ§os , autovetores e autovalores

Um vetor v Ã© um autovetor de uma matriz quadrada M se

              Mv=ï¬v

Escalar ï¬ Ã© autovalor de M associado ao autovetor v.
         Descritores de forma
Ãrea e RetÃ¢ngulos envolventes
      Ã‰ necessÃ¡rio que a imagem tinha sido segmentada
 PerÃ­metro, Alongamento e Retangularidade



PerÃ­metro - nÃºmero de pixels conexos que constituem
  o contorno da regiÃ£o.

Alongamento - relaÃ§Ã£o de lados do menor retÃ¢ngulo
  que envolve o objeto.

Retangularidade - relaÃ§Ã£o entre a Ã¡rea do objeto e
  Ã¡rea do menor retÃ¢ngulo que o envolve.
      Excentricidade, diÃ¢metro, raio mÃ¡ximo e
                 mÃ­nimo do objeto


DiÃ¢metro de um objeto -            maior
  distÃ¢ncia entre 2 pontos deste objeto.
Excentricidade - relaÃ§Ã£o entre dois
  pontos extremos do objeto que
  passem pelo eixo maior e eixo
  ortogonal.
Raio mÃ¡ximo e mÃ­nimo do objeto -
  distÃ¢ncias mÃ¡xima e mÃ­nima,
  respectivamente, da borda ao centro
  geomÃ©trico.
                         Contornos




                 (a)                      (b)
Exemplo de aplicaÃ§Ã£o do filtro de gradiente (b) para acentuar o
 contorno em uma imagem de tomografia (a). Neste exemplo
   foram realizados procedimentos para ligaÃ§Ã£o de bordas.
           CÃ³digo da Cadeia




             2
                                           4
                                       5
                                                     3



3            P             1   7               P         2




                                   6                 1
                                           0
             0

VizinhanÃ§a-4 de p, N4(p)           VizinhanÃ§a-8 de p, N8(p)
   (a)                                 (b)
Pontos onde o cÃ³digo se diferencia do vizinho.
â€¢ 10/10
â€¢ Maria
â€¢ Luis
â€¢ Yuri
â€¢ Javier
         Transformada de Hough


  Transformar a imagem do espaÃ§o digital (x,y) para uma
representaÃ§Ã£o na forma dos parÃ¢metros descritos pela curva
            que se deseja encontrar na imagem




 Etapas da aplicaÃ§Ã£o da transformada de Hough para qualquer forma
                             geomÃ©trica.
Retas:

         y = mx + g
                                                        yh = m x h + g
                                                               yp = m xp + g

                                                              yq = m x q + g

                                                              yr = m x r + g




           espaÃ§o (x,y)           espaÃ§o de parÃ¢metros(m,g)
 â€¢ Cada ponto no espaÃ§o da imagem transforma-se em uma reta no
   espaÃ§o de parÃ¢metro: g = -mx + y.
 â€¢ Para reta vertical m = 0 â” infinita (nÃ£o funciona)
Retas â€“ forma polar:              r = x cosï± + y sin ï±

   y
        L: y=mo.x+co



                                             r

                                            ro

   yp

                 xp                                   ï±ï¯                    ï±
                              x




Plano xy (espaÃ§o de imagem)               Plano ï±r (espaÃ§o de parÃ¢metros)


   Cada ponto P(x,y) no espaÃ§o da imagem, corresponde a uma
            senÃ³ide S(ï²,ï±) no espaÃ§o de parÃ¢metros.
    Algoritmo de Hough (para retas)

1. Discretizar espaÃ§o de parÃ¢metros S(Î¸, r)           y
                                                              L
   em (Î¸min , Î¸max) x (r min, rmax)
                                                          cr         n= (cos Î¸, cos Î¸)
    â€¢   Matriz acumulador A de inteiros                    cÎ¸
                                                                           x
2. Zerar A (valor inicial)
3. Para cada pixel (x,y), com gradiente maior
   que o limiar zero                            EspaÃ§o de imagem
    â€¢   Calcular as coordenadas (cÎ¸, cr) de A
                                                          r
        restrita Ã  linha desejada
                                                              diag
    â€¢   Incrementar: A (cÎ¸, cr) += 1
4. Buscar o mÃ¡ximo local em A â†’ (cÎ¸, cr)        -90                         90
                                                                                 Î¸
5. Converter (cÎ¸, cr) para espaÃ§o de imagem
                                                              -diag


                                                EspaÃ§o de parÃ¢metros
        Circulo: (x - a)2 + (y - b)2 = r2

                                                                          r
    y                                                                                        -n
                           Xp   n = (cos ï±, sen ï±)



                                                                                                   b
                                x

                                                                                 Xp
                                                             a
        EspaÃ§o de imagem
                                                                          EspaÃ§o de parÃ¢metros
â€¢ Acumulador A(_,_,_)
â€¢ 0 ï‚£ r ï‚£ diag // diag diagonal do plano da imagem
â€¢ 0 ï‚£ a, b ï‚£ diag.
                                                                 r
Usando gradiente                                     b= yï‚±                    = y ï‚± r.cos(ï± )
                                                             1 + tan (ï± )
                                                                      2
 ï‚¶
 ï‚¶x
    ï›
    (x âˆ’ a )2 + ( y âˆ’ b )2 = r 2    ï                            r
                                                     a=xï‚±                        = x ï‚± r.sin(ï± )
                                                             1+ 1
                                                                    tan 2 (ï± )
   Histograma de Gradientes Orientados

â€¢ HOG (Histogram of Oriented Gradients)
    ï· Histograma local de gradientes
         â€¢ Ãreas regulares na imagem


     CÃ©lulas                                             Descritor global
 8 x 8 pixels                                            x = (x1,.., x1)


                                      Imagem: 10 x 10
                                          CÃ©lulas

          3 4 10 2 7 6 4 2 17 4 3 3
                                      ïƒŸ (x orientaÃ§Ã£o)
                                    Gradiente
                                                       Kernel:

                                                       No Eixo X: âˆ’1   0 1
                                                                   1
                                                       No Eixo Y: 0
                                                                  âˆ’1



VariaÃ§Ã£o de intensidades (Altas frequÃªncias)
Magnitude
     ğ‘š ğ‘¥ğ‘– , ğ‘¦ğ‘– =   ğœ•ğ‘¥ ğ‘¥ğ‘– , ğ‘¦ğ‘–   2   + ğœ•ğ‘¦ ğ‘¥ğ‘– , ğ‘¦ğ‘–   2


OrientaÃ§Ã£o
                           ğœ•ğ‘¦ ğ‘¥ğ‘– , ğ‘¦ğ‘–
        ğ‘ğ‘›ğ‘” ğ‘¥ğ‘– , ğ‘¦ğ‘– = ğ‘ğ‘‡ğ‘ğ‘›
                           ğœ•ğ‘¥ ğ‘¥ğ‘– , ğ‘¦ğ‘–
             Processo


              Calcular as
               HOG de
               todas as
                cÃ©lulas

                 ang.




3
    2
        1
        16
                    0 22,5 45 66,5   90 â€¦â€¦ 360
                               NormalizaÃ§Ã£o
VariaÃ§Ãµes de iluminaÃ§Ã£o â†’ variam os gradientes

                                                            1       2

                                                             3     4


                                          Bloques




         V1 = (x11, â€¦, x1d, x21, â€¦, x2d, x31, â€¦, x3d, x41, â€¦, x4d)
     Vn1 = (x11, â€¦, x1d, x21, â€¦, x2d, x31, â€¦, x3d, x41, â€¦, x4d) / || V1 ||   Norma L2
                                                  1
       Norma L2:          ğ‘£ = ğœ€+Ïƒ          ğ‘¥ğ‘– 2 2
Vetor HOG




        ConcatenaÃ§Ã£o
            HOG = (x1, â€¦, xn)
Efeitos de SuperposiÃ§Ã£o
 Reconhecimento de PadrÃµes em
           Imagens


â€¢ Reconhecimento de PadrÃµes
â€¢ ClassificaÃ§Ã£o Supervisionada
â€¢ ClassificaÃ§Ã£o NÃ£o Supervisionada
â€¢ Redes Neurais Artificiais
â€¢ LÃ³gica Fuzzy
